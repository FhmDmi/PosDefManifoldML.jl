<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elastic-Net Logistic Regression ¬∑ PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><span class="toctext">ML Models: PD Manifold</span><ul><li><a class="toctext" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="toctext">ML Models: PD Tangent Space</span><ul><li class="current"><a class="toctext" href>Elastic-Net Logistic Regression</a><ul class="internal"></ul></li></ul></li><li><a class="toctext" href="../cv/">fit, predict, cv</a></li></ul></nav><article id="docs"><header><nav><ul><li>ML Models: PD Tangent Space</li><li><a href>Elastic-Net Logistic Regression</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/enlr.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Elastic-Net Logistic Regression</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="enlr.jl-1" href="#enlr.jl-1">enlr.jl</a></h1><p>This unit implements the <strong>elastic net logistic regression (ENLR)</strong> machine learning model on the tangent space for symmetric positive definite (SDP) matrices, <em>i.e.</em>, real PD matrices. This model features two hyperparameters: a user-defined <strong>alpha</strong> hyperparameter, in range <span>$[0, 1]$</span>, where <span>$Œ±=0$</span> allows a pure <strong>Ridge</strong> LR model and <span>$Œ±=1$</span> a pure <strong>lasso</strong> LR model and the <strong>lambda</strong> hyperparameter. When the model is fitted, several models for several values of lambda are created. The &#39;best&#39; model can be estimated by cross-validation using the <a href="#PosDefManifoldML.cvLambda!"><code>cvLambda!</code></a> function.</p><p>The lasso model (default) has enjoyed popularity in the field of <em>brain-computer interaces</em> due to the <a href="http://alexandre.barachant.org/challenges/">winning score</a> obtained in six international data classification competitions.</p><p>The ENLR model is implemented using the Julia package <em>GLMNet.jl</em>. See <a href="../#-1">üéì</a> for resources on GLMNet and learn how to use purposefully this model.</p><p>The <strong>fit</strong> and <strong>predict</strong> functions for the ENRL models are reported in the <a href="../cv/#cv.jl-1">cv.jl</a> unit, since those are shared by all machine learning models. Here it is reported the <a href="#PosDefManifoldML.ENLRmodel"><code>ENLRmodel</code></a> abstract type, the <a href="#PosDefManifoldML.ENLR"><code>ENLR</code></a> structure and the <a href="#PosDefManifoldML.cvLambda!"><code>cvLambda!</code></a> function, which allows to estimate the best model using cross-validation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.ENLRmodel" href="#PosDefManifoldML.ENLRmodel"><code>PosDefManifoldML.ENLRmodel</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">abstract type ENLRmodel&lt;:TSmodel end</code></pre><p>Abstract type for <strong>Elastic Net Logistic Rgression (ENLR)</strong> machine learning models. See <a href="../MainModule/#MLmodel-1">MLmodel</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/356874f9ae9995ba05d941386d454f2b32136d68/src/enlr.jl#L15-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.ENLR" href="#PosDefManifoldML.ENLR"><code>PosDefManifoldML.ENLR</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct ENLR &lt;: ENLRmodel
    metric      :: Metric = Fisher;
    alpha       :: Real
    intercept   :: Bool
    standardize :: Bool
    meanISR     :: Union{‚ÑçVector, Nothing}
    featDim     :: Int
    path        :: GLMNet.GLMNetPath
    cvŒª         :: GLMNet.GLMNetCrossValidation
    bestModel   :: Int
    bestŒª       :: Real
end</code></pre><p>ENLR machine learning models are incapsulated in this mutable structure. Fields:</p><p><code>.metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>, is to be specified by the user. It is the metric that will be adopted to compute the mean used as base-point for tangent space projection.</p><p>All other fields do not correspond to arguments passed upon creation of the model. Instead, they are filled later by the <a href="../cv/#StatsBase.fit"><code>fit</code></a> and <a href="#PosDefManifoldML.cvLambda!"><code>cvLambda!</code></a> functions:</p><p><code>.alpha</code> is the hyperparameter in <span>$[0, 1]$</span> trading-off the <strong>elestic-net model</strong>. <span>$Œ±=0$</span> requests a pure <strong>ridge</strong> model and <span>$Œ±=1$</span> a pure <strong>lasso</strong> model. This is passed as parameter to the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function, defaulting therein to <span>$Œ±=1$</span>.</p><p><code>.intercept</code> is true (default) if the logistic regression model has an intercept term.</p><p><code>.standardize</code>. If true, predictors are standardized so that they are in the same units. By default is true for lasso models (<span>$Œ±=1$</span>), false otherwise (<span>$0‚â§Œ±&lt;1$</span>).</p><p><code>.meanISR</code> is optionally passed to the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function. By default it is computed thereby.</p><p><code>.featDim</code> is the length of the vectorized tangent vectors. This is given by <span>$n(n+1)/2$</span>, where <span>$n$</span> is the dimension of the original PD matrices on which the model is applied once they are mapped onto the tangent space.</p><p><code>.path</code> is the following structure created using the <a href="https://github.com/JuliaStats/GLMNet.jl">GLMNet.jl</a> package when the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function is invoked:</p><pre><code class="language-none">struct GLMNetPath{F&lt;:Distribution}
    family::F                        # Binomial()
    a0::Vector{Float64}              # intercept values for each solution
    betas::CompressedPredictorMatrix # coefficient values for each solution
    null_dev::Float64                # Null deviance of the model
    dev_ratio::Vector{Float64}       # R^2 values for each solution
    lambda::Vector{Float64}          # lambda values for each solution
    npasses::Int                     # actual number of passes over the
                                     # data for all lamda values
end</code></pre><p><code>.cvŒª</code> is the following structure created using the <a href="https://github.com/JuliaStats/GLMNet.jl">GLMNet.jl</a> package when the <a href="#PosDefManifoldML.cvLambda!"><code>cvLambda!</code></a> function is invoked.</p><pre><code class="language-none">struct GLMNetCrossValidation
    path::GLMNetPath            # the cv path
    nfolds::Int                 # the number of folds for the cv
    lambda::Vector{Float64}     # lambda values for each solution
    meanloss::Vector{Float64}   # mean loss for each solution
    stdloss::Vector{Float64}    # standard deviation of the mean losses
end</code></pre><p><code>.bestModel</code> is the serial number of the model in <code>cvŒª.path</code> allowing the minimum <code>cvŒª.meanloss</code>, or the highest <code>cvŒª.meanloss</code> within one standard deviation of the minimum, as specified by the user when invoking the <a href="#PosDefManifoldML.cvLambda!"><code>cvLambda!</code></a> function.</p><p><code>.bestŒª</code> is the value of the lambda hyperparameter corresponding to the <code>bestModel</code>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using PosDefManifoldML

# create an empty model
m = ENLR(Fisher)

# since the Fisher metric is the default metric,
# this is equivalent to
m = ENLR()</code></pre><p>Note that in general you need to invoke these constructors only when an MDM model is needed as an argument to a function, otherwise you will create and fit an ENLR model using the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/356874f9ae9995ba05d941386d454f2b32136d68/src/enlr.jl#L26-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.cvLambda!" href="#PosDefManifoldML.cvLambda!"><code>PosDefManifoldML.cvLambda!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function cvLambda!(model :: ENLRmodel,
                   ùêèTr   :: Union{‚ÑçVector, Matrix{Float64}},
                   yTr   :: Vector;
             w        :: Vector = [],
             ŒªSelMeth :: Symbol = :sd1,
             verbose  :: Bool   = true,
             ‚è©      :: Bool   = true,
             # arguments of GLMNet
             nfolds  :: Int = min(10, div(size(yTr, 1), 3)),
             folds   :: Vector{Int} =
             begin
                 n, r = divrem(size(yTr, 1), nfolds)
                 shuffle!([repeat(1:nfolds, outer=n); 1:r])
             end,
             parallel::Bool=false,
             fitArgs...)</code></pre><p>Run a cross-validation to find the <code>bestModel</code>, using training data <code>ùêèTr</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a>, and corresponding labels <code>yTr</code>, of type <a href="../MainModule/#IntVector-1">IntVector</a>. Return the fitted model filling the <code>model.cvŒª</code> field.</p><div class="admonition note"><div class="admonition-title">Nota bene</div><div class="admonition-text"><p>The <code>model</code> must have been fitted calling the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function before calling this function.</p></div></div><p>The optionl <code>w</code> weights are passed to the <a href="../tools/#PosDefManifoldML.tsMap"><code>tsMap</code></a> function, as in the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function. By defaults all weights are equal to 1, but here too they should be inversely proportional to the number of examples for each class, in such a way that each class contributes equally to the computation of the mean for projecting the matrices onto the tangent space.</p><p>If <code>ŒªSelMeth</code> = <code>:sd1</code> (default), the best model is the one allowing the highest <code>cvŒª.meanloss</code> within one standard deviation of the minimum, otherwise it is the one allowing the minimum <code>cvŒª.meanloss</code>. Note that in selecting a model, the model with only the intercept term, which is the first model if the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function has been run with argument <code>intercept</code>=true (default), is ignored.</p><p>If <code>verbose</code> is true (default), information is printed in the REPL. This option is included to allow repeated calls to this function without crowding the REPL.</p><p>The <code>‚è©</code> argument (true by default) is passed to the <a href="../tools/#PosDefManifoldML.tsMap"><code>tsMap</code></a> function for projecting the matrices in <code>ùêèTr</code> onto the tangent space.</p><p>Arguments <code>nfolds</code>, <code>folds</code> and <code>parallel</code> are passed to the <code>GLMNet.glmnetcv</code> function. Please refer to the resources on GLMNet for details <a href="../#-1">üéì</a>.</p><p>Arguments <code>fitArgs...</code> may be any set of <strong>fitArgs</strong> arguments to be passed to the <em>GLMNet.glmnet</em> function. See the documentation of the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

# generate some data
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.25)

# create and fit an ENLR lasso model:
m=fit(ENLR(Fisher), PTr, yTr)

# estimate the best model by cross-validation
cvLambda!(m, PTr, yTr)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/356874f9ae9995ba05d941386d454f2b32136d68/src/enlr.jl#L368-L443">source</a></section><footer><hr/><a class="previous" href="../mdm/"><span class="direction">Previous</span><span class="title">Minimum Distance to Mean</span></a><a class="next" href="../cv/"><span class="direction">Next</span><span class="title">fit, predict, cv</span></a></footer></article></body></html>
