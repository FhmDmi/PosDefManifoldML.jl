<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Minimum Distance to Mean ¬∑ PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><span class="toctext">ML Models: PD Manifold</span><ul><li class="current"><a class="toctext" href>Minimum Distance to Mean</a><ul class="internal"></ul></li></ul></li><li><span class="toctext">ML Models: PD Tangent Space</span><ul><li><a class="toctext" href="../enlr/">Elastic-Net Logistic Regression</a></li></ul></li><li><a class="toctext" href="../cv/">fit, predict, cv</a></li></ul></nav><article id="docs"><header><nav><ul><li>ML Models: PD Manifold</li><li><a href>Minimum Distance to Mean</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/mdm.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Minimum Distance to Mean</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="mdm.jl-1" href="#mdm.jl-1">mdm.jl</a></h1><p>This unit implements the Riemannian <strong>MDM (Minimum Distance to Mean)</strong> classifier for the manifold of positive definite (PD) matrices, both real (symmetric PD) or complex (Hermitian PD) matrices. The MDM is a <em>simple</em>, yet <em>efficient</em>, <em>deterministic</em> and <em>paramater-free</em> classifier acting directly on the manifold of positive definite matrices (Barachat el <em>al.</em>, 2012; Congedo et <em>al.</em>, 2017a <a href="../#-1">üéì</a>): given a number of PD matrices representing <em>class means</em>, the MDM classify an unknown datum (also a PD matrix) as belonging to the class whose mean is the closest to the datum. The process is illustrated in the upper part of this <a href="https://raw.githubusercontent.com/Marco-Congedo/PosDefManifoldML.jl/master/docs/src/assets/Fig1.jpg">figure</a>.</p><p>The MDM classifier involves only the concepts of a <em>distance function</em> for two PD matrices and a <em>mean</em> (center of mass) for a number of them. Those are defined for any given metric, a <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a> enumerated type declared in <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/">PosDefManifold</a>.</p><p>Currently supported metrics are:</p><table><tr><th style="text-align: left">metric (distance)</th><th style="text-align: left">mean estimation</th><th style="text-align: left">known also as</th></tr><tr><td style="text-align: left">Euclidean</td><td style="text-align: left">arithmetic</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">invEuclidean</td><td style="text-align: left">harmonic</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">ChoEuclidean</td><td style="text-align: left">Cholesky Euclidean</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">logEuclidean</td><td style="text-align: left">log-Euclidean</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">logCholesky</td><td style="text-align: left">log-Cholesky</td><td style="text-align: left"></td></tr><tr><td style="text-align: left">Fisher</td><td style="text-align: left">Fisher</td><td style="text-align: left">Cartan, Karcher, Pusz-Woronowicz, Affine-Invariant, ...</td></tr><tr><td style="text-align: left">logdet0</td><td style="text-align: left">logDet</td><td style="text-align: left">S, Œ±, Bhattacharyya, Jensen, ...</td></tr><tr><td style="text-align: left">Jeffrey</td><td style="text-align: left">Jeffrey</td><td style="text-align: left">symmetrized Kullback-Leibler</td></tr><tr><td style="text-align: left">Wasserstein</td><td style="text-align: left">Wasserstein</td><td style="text-align: left">Bures, Hellinger, optimal transport, ...</td></tr></table><p>Do not use the Von Neumann metric, which is also supported in <em>PosDefManifold</em>, since it does not allow a definition of mean. See <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/introToRiemannianGeometry/">here</a> for details on the metrics.</p><p>The <strong>fit</strong> and <strong>predict</strong> functions for the MDM models are reported in the <a href="../cv/#cv.jl-1">cv.jl</a> unit. Here it is reported the <a href="#PosDefManifoldML.MDMmodel"><code>MDMmodel</code></a> abstract type, the <a href="#PosDefManifoldML.MDM"><code>MDM</code></a> structure and the following functions, which typically you will not need to access directly, but are nonetheless provided to facilitate low-level operations with MDM classifiers:</p><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.getMean"><code>getMean</code></a></td><td style="text-align: left">compute the mean of positive definite matrices for fitting the MDM model</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.getDistances"><code>getDistances</code></a></td><td style="text-align: left">compute the distances of a matrix set to a set of means</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.MDMmodel" href="#PosDefManifoldML.MDMmodel"><code>PosDefManifoldML.MDMmodel</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>Abstract type for MDM (Minimum Distance to Mean) machine learning models</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/26d9bbda270387b5dd3c8b20311bbf60f24b7463/src/mdm.jl#L15-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.MDM" href="#PosDefManifoldML.MDM"><code>PosDefManifoldML.MDM</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct MDM &lt;: MDMmodel
    metric  :: Metric = Fisher;
    featDim :: Int
    means   :: ‚ÑçVector
end</code></pre><p>MDM machine learning models are incapsulated in this mutable structure. MDM models have three fields: <code>.metric</code>, <code>.featDim</code> and <code>.means</code>.</p><p>The field <code>metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>, is to be specified by the user. It is the metric that will be adopted to compute the class means and the distances to the mean.</p><p>The field <code>featDim</code> is the dimension of the manifold in which the model acts. This is given by <span>$n(n+1)/2$</span>, where <span>$n$</span> is the dimension of the PD matrices. This field is not to be specified by the user, instead, it is computed when the MDM model is fit using the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function and is accessible only thereafter.</p><p>The field <code>means</code> is an <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a> holding the class means, i.e., one mean for each class. This field is not to be specified by the user, instead, the means are computed when the MDM model is fit using the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function and are accessible only thereafter.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using PosDefManifoldML

# create an empty model
m = MDM(Fisher)

# since the Fisher metric is the default metric,
# this is equivalent to
m = MDM()</code></pre><p>Note that in general you need to invoke these constructors only when an MDM model is needed as an argument to a function, otherwise you can more simply create and fit an MDM model using the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/26d9bbda270387b5dd3c8b20311bbf60f24b7463/src/mdm.jl#L22-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.getMean" href="#PosDefManifoldML.getMean"><code>PosDefManifoldML.getMean</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function getMean(metric :: Metric,
                 ùêè      :: ‚ÑçVector;
              w        :: Vector = [],
              ‚úìw       :: Bool    = true,
              meanInit :: Union{‚Ñç, Nothing} = nothing,
              tol      :: Real   = 0.,
              ‚è©      :: Bool    = true)</code></pre><p>Typically, you will not need this function as it is called by the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function.</p><p>Given a <code>metric</code> of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>, an <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a> of Hermitian matrices <code>ùêè</code> and an optional non-negative real weights vector <code>w</code>, return the (weighted) mean of the matrices in <code>ùêè</code>. This is used to fit MDM models.</p><p>This function calls the appropriate mean functions of package <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/">PostDefManifold</a>, depending on the chosen <code>metric</code>, and check that, if the mean is found by an iterative algorithm, then the iterative algorithm converges.</p><p>See method (3) of the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#Statistics.mean">mean</a> function for the meaning of the optional keyword arguments <code>w</code>, <code>‚úìw</code>, <code>meanInit</code>, <code>tol</code> and <code>‚è©</code>, to which they are passed.</p><p>The returned mean is flagged by Julia as an Hermitian matrix (see <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/26d9bbda270387b5dd3c8b20311bbf60f24b7463/src/mdm.jl#L290-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.getDistances" href="#PosDefManifoldML.getDistances"><code>PosDefManifoldML.getDistances</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function getDistances(metric :: Metric,
                      means  :: ‚ÑçVector,
                      ùêè      :: ‚ÑçVector;
                scale :: Bool = false,
                  ‚è© :: Bool = true)</code></pre><p>Typically, you will not need this function as it is called by the <a href="../cv/#GLMNet.predict"><code>predict</code></a> function.</p><p>Given an <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a> <code>ùêè</code> holding <span>$k$</span> Hermitian matrices and an ‚ÑçVector <code>means</code> holding <span>$z$</span> matrix means, return the <em>square of the distance</em> of each matrix in <code>ùêè</code> to the means in <code>means</code>.</p><p>The squared distance is computed according to the chosen <code>metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>. See <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/introToRiemannianGeometry/#metrics-1">metrics</a> for details on the supported distance functions.</p><p>If <code>scale</code> is true, the distances are divided by the size of the matrices in <code>ùêè</code>. This is used to compare disctances computed on manifolds with different dimensions.</p><p>If <code>‚è©</code> is true, the distances are computed using multi-threading, unless the number of threads Julia is instructed to use is &lt;2 or &lt;3k.</p><p>The result is a <span>$z$</span>x<span>$k$</span> matrix of squared distances.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/26d9bbda270387b5dd3c8b20311bbf60f24b7463/src/mdm.jl#L357-L389">source</a></section><footer><hr/><a class="previous" href="../tools/"><span class="direction">Previous</span><span class="title">Tools</span></a><a class="next" href="../enlr/"><span class="direction">Next</span><span class="title">Elastic-Net Logistic Regression</span></a></footer></article></body></html>
