<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>fit, predict, cv ¬∑ PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><span class="toctext">ML Models: PD Manifold</span><ul><li><a class="toctext" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="toctext">ML Models: PD Tangent Space</span><ul><li><a class="toctext" href="../enlr/">Elastic-Net Logistic Regression</a></li></ul></li><li class="current"><a class="toctext" href>fit, predict, cv</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>fit, predict, cv</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/cv.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>fit, predict, cv</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="cv.jl-1" href="#cv.jl-1">cv.jl</a></h1><p>This unit implements <strong>cross-validation</strong> procedures for estimating the <strong>accuracy</strong> and <strong>balanced accuracy</strong> of machine learning models. It also reports the documentation of the <strong>fit</strong> and <strong>predict</strong> functions, as they are common to all models.</p><p><strong>Content</strong></p><table><tr><th style="text-align: left">struct</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.CVacc"><code>CVacc</code></a></td><td style="text-align: left">encapsulate the result of cross-validation procedures for estimating accuracy</td></tr></table><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#StatsBase.fit"><code>fit</code></a></td><td style="text-align: left">fit a model with training data, or create and fit it</td></tr><tr><td style="text-align: left"><a href="#GLMNet.predict"><code>predict</code></a></td><td style="text-align: left">preidct labels, probabilities or scoring functions on test data</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a></td><td style="text-align: left">estimate accuracy of a model by cross-validation</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.cvSetup"><code>cvSetup</code></a></td><td style="text-align: left">generate indexes for performing cross-validtions</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.CVacc" href="#PosDefManifoldML.CVacc"><code>PosDefManifoldML.CVacc</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct CVacc
    cvType  :: String
    scoring :: Union{String, Nothing}
    model   :: Union{MLmodel, Nothing}
    cnfs    :: Union{Vector{Matrix{T}}, Nothing} where T&lt;:Real
    avgCnf  :: Union{Matrix{T}, Nothing} where T&lt;:Real
    accs    :: Union{Vector{T}, Nothing} where T&lt;:Real
    avgAcc  :: Union{Real, Nothing}
    stdAcc  :: Union{Real, Nothing}
end</code></pre><p>A call to <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a> results in an instance of this structure. Fields:</p><p><code>.cvTpe</code> is the type of cross-validation technique, given as a string (e.g., &quot;10-kfold&quot;)</p><p><code>.scoring</code> is the type of accuracy that is computed, given as a string. This has been passed as argument to <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a>. Currently <em>accuracy</em> and <em>balanced accuracy</em> are supported.</p><p><code>.model</code> is the machine learning model that has been passed as argument to <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a>, e.g., an <a href="../mdm/#PosDefManifoldML.MDMmodel"><code>MDMmodel</code></a> or an <a href="../enlr/#PosDefManifoldML.ENLRmodel"><code>ENLRmodel</code></a>.</p><p><code>.cnfs</code> is a vector of matrices holding the <em>confusion matrices</em> obtained at each fold of the cross-validation.</p><p><code>.avgCnf</code> is the <em>average confusion matrix</em> across the folds of the cross-validation.</p><p><code>.accs</code> is a vector of real numbers holding the <em>accuracies</em> obtained at each fold of the cross-validation.</p><p><code>.avgAcc</code> is the <em>average accuracy</em> across the folds of the cross-validation.</p><p><code>.stdAcc</code> is the <em>standard deviation of the accuracy</em> across the folds of the cross-validation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/c86d22a8a43329fc55919bbd2ef37f26113e2159/src/cv.jl#L14-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit" href="#StatsBase.fit"><code>StatsBase.fit</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function fit(model :: MDMmodel,
              ùêèTr   :: ‚ÑçVector,
              yTr   :: Vector;
           w       :: Vector = [],
           ‚úìw      :: Bool  = true,
           verbose :: Bool  = true,
           ‚è©      :: Bool  = true)</code></pre><p>Fit an <a href="../mdm/#PosDefManifoldML.MDM"><code>MDM</code></a> machine learning model, with training data <code>ùêèTr</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a>, and corresponding labels <code>yTr</code>, of type <a href="../MainModule/#IntVector-1">IntVector</a>. Return the fitted model.</p><p>Fitting an MDM model involves only computing a mean of all the matrices in each class. Those class means are computed according to the metric specified by the <a href="../mdm/#PosDefManifoldML.MDM"><code>MDM</code></a> constructor.</p><p>See method (3) of the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#Statistics.mean">mean</a> function for the meaning of the optional keyword arguments <code>w</code>, <code>‚úìw</code> and <code>‚è©</code>, to which they are passed. Keep in mind that here the weights should sum up to 1 separatedly for each class, which is what is ensured if <code>‚úìw</code> is true.</p><p>If <code>verbose</code> is true (default), information is printed in the REPL. This option is included to allow repeated calls to this function without crowding the REPL.</p><p><strong>See</strong>: <a href="../MainModule/#notation-and-nomenclature-1">notation &amp; nomenclature</a>, <a href="../MainModule/#the-‚ÑçVector-type-1">the ‚ÑçVector type</a>.</p><p><strong>See also</strong>: <a href="#GLMNet.predict"><code>predict</code></a>, <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

# generate some data
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.25)

# create and fit a model:
m=fit(MDM(Fisher), PTr, yTr)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/c86d22a8a43329fc55919bbd2ef37f26113e2159/src/mdm.jl#L86-L132">source</a><div><div><pre><code class="language-none">function fit(model :: ENLRmodel,
              ùêèTr   :: Union{‚ÑçVector, Matrix{Float64}},
              yTr   :: Vector;
           w       :: Vector            = [],
           meanISR :: Union{‚Ñç, Nothing} = nothing,
           verbose :: Bool              = true,
           ‚è©     :: Bool               = true,
           # (GLMNet) fitArgs
           alpha            :: Real = model.alpha &lt; 1.0 ? model.alpha : 1.0,
           intercept        :: Bool = true,
           standardize      :: Bool = alpha‚âà1.0 ? true : false,
           penalty_factor   :: Vector{Float64} = ones(_triNum(ùêèTr[1])),
           constraints      :: Matrix{Float64} = [x for x in (-Inf, Inf), y in 1:_triNum(ùêèTr[1])],
           offsets          :: Union{Vector{Float64}, Nothing} = nothing,
           dfmax            :: Int = _triNum(ùêèTr[1]),
           pmax             :: Int = min(dfmax*2+20, _triNum(ùêèTr[1])),
           nlambda          :: Int = 100,
           lambda_min_ratio :: Real = (length(yTr) &lt; _triNum(ùêèTr[1]) ? 1e-2 : 1e-4),
           lambda           :: Vector{Float64} = Float64[],
           tol              :: Real = 1e-7,
           maxit            :: Int = 1000000,
           algorithm        :: Symbol = :newtonraphson)
</code></pre><p>Fit an <a href="../enlr/#PosDefManifoldML.ENLR"><code>ENLR</code></a> machine learning model, with training data <code>ùêèTr</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a>, and corresponding labels <code>yTr</code>, of type <a href="../MainModule/#IntVector-1">IntVector</a>. Return the fitted model.</p><p>Fitting an ENLR model involves computing a mean of all the matrices in <code>ùêèTr</code>, mapping all matrices onto the tangent space after parallel transporting them at the identity matrix and vectorizing them using the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> operation. Once this is done the elastic net logistic regression is fitted.</p><p>The mean is computed according to the <code>.metric</code> field of the <code>model</code>, with optional weights <code>w</code>. If weights are used, they should be inversely proportional to the number of examples for each class, in such a way that each class contributes equally to the computation of the mean. This argument is passed to the <a href="../tools/#PosDefManifoldML.tsMap"><code>tsMap</code></a> function.</p><p>If <code>meanISR</code> is passed as argument, the mean is not computed, instead this matrix is the inverse square root (ISR) of the mean used for projecting the matrices in the tangent space (see <a href="../tools/#PosDefManifoldML.tsMap"><code>tsMap</code></a>).</p><p>If <code>verbose</code> is true (default), information is printed in the REPL. This option is included to allow repeated calls to this function without crowding the REPL.</p><p>The <code>‚è©</code> argument (true by default) is passed to the <a href="../tools/#PosDefManifoldML.tsMap"><code>tsMap</code></a> function for projecting the matrices in <code>ùêèTr</code> onto the tangent space.</p><p>The remaining optional arguments, referred to as <strong>fitArgs</strong>, are passed to the <em>GLMNet.glmnet</em> function to fit the elastic-net model.</p><p><code>weights</code>: a vector of weights for each matrix of the same size as <code>yTr</code>. Argument <code>w</code> is passed, defaulting to 1 for all matrices.</p><p><code>alpha</code>: the hyperparameter in <span>$[0, 1]$</span> to trade-off an elestic-net model. <span>$Œ±=0$</span> requests a pure <em>ridge</em> model and <span>$Œ±=1$</span> a pure <em>lasso</em> model. This defaults to 1.0, which specifies a lasso model.</p><p><code>intercept</code>: whether to fit an intercept term. The intercept is always unpenalized. Defaults to true.</p><p><code>standardize</code>: whether to standardize predictors so that they are in the same units. Differently from <em>GLMNet.jl</em>, by default this is true for lasso models (<span>$Œ±=1$</span>), false otherwise (<span>$0‚â§Œ±&lt;1$</span>).</p><p><code>penalty_factor</code>: a vector of length <span>$n(n+1)/2$</span>, where <span>$n$</span> is the dimension of the original PD matrices on which the model is applied, of penalties for each predictor in the tangent vectors. This defaults to all ones, which weights each predictor equally. To specify that a predictor should be unpenalized, set the corresponding entry to zero.</p><p><code>constraints</code>: an <span>$n(n+1)/2$</span> x <span>$2$</span> matrix specifying lower bounds (first column) and upper bounds (second column) on each predictor. By default, this is [-Inf Inf] for each predictor (each element of tangent vectors).</p><p><code>dfmax</code>: The maximum number of predictors in the largest model.</p><p><code>pmax</code>: The maximum number of predictors in any model.</p><p><code>nlambda</code>: The number of values of <span>$Œª$</span> along the path to consider.</p><p><code>lambda_min_ratio</code>: The smallest <span>$Œª$</span> value to consider, as a ratio of the value of <span>$Œª$</span> that gives the null model (<em>i.e.</em>, the model with only an intercept). If the number of observations exceeds the number of variables, this defaults to 0.0001, otherwise 0.01.</p><p><code>lambda</code>: The <span>$Œª$</span> values to consider. By default, this is determined from <code>nlambda</code> and <code>lambda_min_ratio</code>.</p><p><code>tol</code>: Convergence criterion. Defaults to 1e-7.</p><p><code>maxit</code>: The maximum number of iterations of the cyclic coordinate descent algorithm. If convergence is not achieved, a warning is returned.</p><p><code>algorithm</code>: the algorithm used to find the <code>path</code>.</p><p>For further informations on the <strong>fitArgs</strong> arguments, refer to the resources on the GLMNet package <a href="../#-1">üéì</a>.</p><p><strong>See</strong>: <a href="../MainModule/#notation-and-nomenclature-1">notation &amp; nomenclature</a>, <a href="../MainModule/#the-‚ÑçVector-type-1">the ‚ÑçVector type</a>.</p><p><strong>See also</strong>: <a href="#GLMNet.predict"><code>predict</code></a>, <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

# generate some data
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.25)

# create and fit an ENLR lasso model:
m=fit(ENLR(Fisher), PTr, yTr)

# create and fit an ENLR ridge model:
m=fit(ENLR(Fisher), PTr, yTr; alpha=0)

# create and fit an ENLR elastic net model with alpha=0.9:
m=fit(ENLR(Fisher), PTr, yTr; alpha=0.9)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/c86d22a8a43329fc55919bbd2ef37f26113e2159/src/enlr.jl#L158-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GLMNet.predict" href="#GLMNet.predict"><code>GLMNet.predict</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function predict(model  :: MDMmodel,
                 ùêèTe    :: ‚ÑçVector,
                 what   :: Symbol = :labels;
               verbose :: Bool = true,
               ‚è©     :: Bool = true)</code></pre><p>Given an <a href="../mdm/#PosDefManifoldML.MDM"><code>MDM</code></a> <code>model</code> trained (fitted) on <span>$z$</span> classes and a testing set of <span>$k$</span> positive definite matrices <code>ùêèTe</code> of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a>,</p><p>if <code>what</code> is <code>:labels</code> or <code>:l</code> (default), return the predicted <strong>class labels</strong> for each matrix in <code>ùêèTe</code> as an <a href="../MainModule/#IntVector-1">IntVector</a>;</p><p>if <code>what</code> is <code>:probabilities</code> or <code>:p</code>, return the predicted <strong>probabilities</strong> for each matrix in <code>ùêèTe</code> to belong to a all classes, as a <span>$k$</span>-vector of <span>$z$</span> vectors holding reals in <span>$[0, 1]$</span> (probabilities).</p><p>if <code>what</code> is <code>:f</code> or <code>:functions</code>, return the <strong>output function</strong> of the model (see below).</p><p>If <code>verbose</code> is true (default), information is printed in the REPL. This option is included to allow repeated calls to this function without crowding the REPL.</p><p>It f <code>‚è©</code> is true (default), the computation of distances is multi-threaded.</p><p>For MDM models, the predicted class &#39;label&#39; of an unlabeled matrix is the serial number of the class whose mean is the closest to the matrix (minimum distance to mean). The labels are &#39;1&#39; for class 1, &#39;2&#39; for class 2, etc.</p><p>The &#39;probabilities&#39; are obtained passing to a <a href="https://en.wikipedia.org/wiki/Softmax_function">softmax function</a> minus the squared distances of each unlabeled matrix to all class means.</p><p>The ratio of these squared distance to their geometric mean gives the &#39;functions&#39;.</p><p><strong>See</strong>: <a href="../MainModule/#notation-and-nomenclature-1">notation &amp; nomenclature</a>, <a href="../MainModule/#the-‚ÑçVector-type-1">the ‚ÑçVector type</a>.</p><p><strong>See also</strong>: <a href="#StatsBase.fit"><code>fit</code></a>, <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a>, <a href="../tools/#PosDefManifoldML.predictErr"><code>predictErr</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

# generate some data
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80)

# craete and fit an MDM model
m=fit(MDM(Fisher), PTr, yTr)

# predict labels
yPred=predict(m, PTe, :l)

# prediction error
predErr=predictErr(yTe, yPred)

# predict probabilities
predict(m, PTe, :p)

# output functions
predict(m, PTe, :f)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/c86d22a8a43329fc55919bbd2ef37f26113e2159/src/mdm.jl#L163-L230">source</a><div><div><pre><code class="language-none">function predict(model  :: ENLRmodel,
                 ùêèTe    :: Union{‚ÑçVector, Matrix{Float64}},
                 what   :: Symbol = :labels,
                 which  :: Union{Int, Nothing} = model.bestModel;
            verbose :: Bool = true,
            ‚è©     :: Bool = true)</code></pre><p>Given an <a href="../enlr/#PosDefManifoldML.ENLR"><code>ENLR</code></a> <code>model</code> trained (fitted) on 2 classes and a testing set of <span>$k$</span> positive definite matrices <code>ùêèTe</code> of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a>,</p><p>if <code>what</code> is <code>:labels</code> or <code>:l</code> (default), return the predicted <strong>class labels</strong> for each matrix in <code>ùêèTe</code> as an <a href="../MainModule/#IntVector-1">IntVector</a>;</p><p>if <code>what</code> is <code>:probabilities</code> or <code>:p</code>, return the predicted <strong>probabilities</strong> for each matrix in <code>ùêèTe</code> to belong to a all classes, as a <span>$k$</span>-vector of <span>$z$</span> vectors holding reals in <span>$[0, 1]$</span> (probabilities).</p><p>if <code>what</code> is <code>:f</code> or <code>:functions</code>, return the <strong>output function</strong> of the model (see below).</p><p>If <code>verbose</code> is true (default), information is printed in the REPL. This option is included to allow repeated calls to this function without crowding the REPL.</p><p>The predicted class &#39;label&#39; are &#39;1&#39; for class 1 and &#39;2&#39; for class 2.</p><p>The &#39;probabilities&#39; are obtained passing to a <a href="https://en.wikipedia.org/wiki/Softmax_function">softmax function</a> the output of the ENLR model and zero.</p><p>The &#39;functions&#39; are the raw output of the ENLR model.</p><p>If the <a href="../enlr/#PosDefManifoldML.cvLambda!"><code>cvLambda!</code></a> function has been previously called on the <code>model</code>, the best model for the model has been selected and by default this model will be used for prediction, otherwise</p><ul><li><p>if <code>which</code> is a valid serial number for a model in the <code>model.path</code>, this model is used for prediction,</p></li><li><p>if <code>which</code> is zero, all model in the <code>model.path</code> will be used for predictions, thus the output will be multiplied by the number of models in <code>model.path</code>.</p></li></ul><p><strong>See</strong>: <a href="../MainModule/#notation-and-nomenclature-1">notation &amp; nomenclature</a>, <a href="../MainModule/#the-‚ÑçVector-type-1">the ‚ÑçVector type</a>.</p><p><strong>See also</strong>: <a href="#StatsBase.fit"><code>fit</code></a>, <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a>, <a href="../tools/#PosDefManifoldML.predictErr"><code>predictErr</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

# generate some data
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80)

# craete and fit an ENLR lasso model
m=fit(ENLR(Fisher), PTr, yTr)

# estimate the best model by cross-validation
cvLambda!(m, PTr, yTr)

# predict labels using the best model
yPred=predict(m, PTe, :l)
# prediction error
predErr=predictErr(yTe, yPred)

# predict labels using a specific model
yPred=predict(m, PTe, :l, 10)

# predict labels for all models
yPred=predict(m, PTe, :l, 0)
# prediction error for all models
predErr=[predictErr(yTe, yPred[:, i]) for i=1:size(yPred, 2)]

# predict probabilities using best model
predict(m, PTe, :p)

# predict probabilities using a specific model
predict(m, PTe, :p, 12)

# predict probabilities for all models
predict(m, PTe, :p, 0)

# output functions using best model
predict(m, PTe, :f)

# output functions using a specific model
predict(m, PTe, :f, 3)

# output functions for all models
predict(m, PTe, :f, 0)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/c86d22a8a43329fc55919bbd2ef37f26113e2159/src/enlr.jl#L508-L603">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.cvAcc" href="#PosDefManifoldML.cvAcc"><code>PosDefManifoldML.cvAcc</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function cvAcc(model   :: MLmodel,
               ùêèTr     :: ‚ÑçVector,
               yTr     :: IntVector,
               nCV     :: Int;
           scoring   :: Symbol = :b,
           shuffle   :: Bool   = false,
           verbose   :: Bool   = true,
           fitArgs...)</code></pre><p>Cross-validation accuracy for a machine learning <code>model</code>: given an ‚ÑçVector <code>ùêèTr</code> holding <span>$k$</span> Hermitian matrices, an <a href="../MainModule/#IntVector-1">IntVector</a> <code>yTr</code> holding the <span>$k$</span> labels for these matrices and the number of cross-validations <code>nCV</code>, return a <a href="#PosDefManifoldML.CVacc"><code>CVacc</code></a> structure.</p><p>If <code>scoring</code>=:b (default) the <strong>balanced accuracy</strong> is computed. Any other value will make the function returning the regular <strong>accuracy</strong>. Balanced accuracy is to be preferred for unbalanced classes. In any case, for balanced classes the balanced accuracy reduces to the regular accuracy, therefore there is no point in using regular accuracy.</p><p><strong>See</strong>: <a href="../MainModule/#notation-and-nomenclature-1">notation &amp; nomenclature</a>, <a href="../MainModule/#the-‚ÑçVector-type-1">the ‚ÑçVector type</a>.</p><p><strong>See also</strong>: <a href="#StatsBase.fit"><code>fit</code></a>, <a href="#GLMNet.predict"><code>predict</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

# generate some data
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80)

# perform cross-validation using the minimum distance to mean classifier
cv=cvAcc(MDM(Fisher), PTr, yTr, 10)

# ...using the lasso logistic regression classifier
cv=cvAcc(ENLR(Fisher), PTr, yTr, 10)

# ...using the elastic-net logistic regression (Œ±=0.9) classifier
cv=cvAcc(ENLR(Fisher), PTr, yTr, 10; alpha=0.9)

# perform another cross-validation
cv=cvAcc(MDM(Fisher), PTr, yTr, 10; shuffle=true)

</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/c86d22a8a43329fc55919bbd2ef37f26113e2159/src/cv.jl#L82-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.cvSetup" href="#PosDefManifoldML.cvSetup"><code>PosDefManifoldML.cvSetup</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function cvSetup(k       :: Int,
                 nCV     :: Int;
                 shuffle :: Bool = false)</code></pre><p>Given <code>k</code> elements and a parameter <code>nCV</code>, a nCV-fold cross-validation is obtained defining <span>$nCV$</span> permutations of <span>$k$</span> elements in <span>$nTest=k√∑nCV$</span> (integer division) elements for the test and <span>$k-nTest$</span> elements for the training, in such a way that each element is represented in only one permutation.</p><p>Said differently, given a length <code>k</code> and the number of desired cross-validations <code>nCV</code>, this function generates indices from the sequence of natural numbers <span>$1,..,k$</span> to obtain all nCV-fold cross-validation sets. Specifically, it generates <span>$nCV$</span> vectors of indices for generating test sets and <span>$nCV$</span> vectors of indices for geerating training sets.</p><p>If optional keyword argument <code>shuffle</code> is true, the sequence of natural numbers <span>$1,..,k$</span> is shuffled before running the function, thus in this case two successive runs of this function will give different cross-validation sets, hence different accuracy scores. By default <code>shuffle</code> is false, so as to allow exactly the same result in successive runs. Note that no random initialization for the shuffling is provided, so as to allow the replication of the same random sequences starting again the random generation from scratch.</p><p>This function is used in <a href="#PosDefManifoldML.cvAcc"><code>cvAcc</code></a>. It constitutes the fundamental basis to implement customized cross-validation procedures.</p><p>Return the 2-tuple with:</p><ul><li>A vector of <code>nCV</code> vectors holding the indices for the training sets,</li><li>A vector of <code>nCV</code> vectors holding the indices for the corresponding test sets.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

cvSetup(10, 2)
# return:
# (Array{Int64,1}[[6, 7, 8, 9, 10], [1, 2, 3, 4, 5]],
#  Array{Int64,1}[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

cvSetup(10, 2, shuffle=true)
# return:
# (Array{Int64,1}[[5, 4, 6, 1, 9], [3, 7, 8, 2, 10]],
#  Array{Int64,1}[[3, 7, 8, 2, 10], [5, 4, 6, 1, 9]])

cvSetup(10, 3)
# return:
# (Array{Int64,1}[[4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6]],
#  Array{Int64,1}[[1, 2, 3], [4, 5, 6], [7, 8, 9, 10]])
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/c86d22a8a43329fc55919bbd2ef37f26113e2159/src/cv.jl#L209-L266">source</a></section><footer><hr/><a class="previous" href="../enlr/"><span class="direction">Previous</span><span class="title">Elastic-Net Logistic Regression</span></a></footer></article></body></html>
