<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Example-using-the-MDM-model-1">Example using the MDM model</a></li><li><a class="toctext" href="#Example-using-the-ENLR-model-1">Example using the ENLR model</a></li></ul></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><span class="toctext">ML Models: PD Manifold</span><ul><li><a class="toctext" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="toctext">ML Models: PD Tangent Space</span><ul><li><a class="toctext" href="../enlr/">Elastic-Net Logistic Regression</a></li></ul></li><li><a class="toctext" href="../cv/">fit, predict, cv</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><p><em>PosDefManifoldML</em> features two bacic <strong>pipelines</strong>:</p><p><strong>1)</strong> a machine learning (ML) model is first <strong>fit</strong> (trained), then it can be used to <strong>predict</strong> the <em>labels</em> of testing data or the <em>probability</em> of the data to belong to each class. The raw prediction function of the models is available as well.</p><p><strong>2)</strong> a <strong>k-fold cross-validation</strong> procedure allows to estimate the <strong>accuracy</strong> of ML models and compare them.</p><p>What <em>PosDefManifoldML</em> does for you is to allow an homogeneous syntax to run these two pipelines for all implemented ML models, it does not matter if they act directly on the manifold of positive definite matrices or on the tangent space.</p><p><strong>get data</strong></p><p>A real data example will be added soon. For now, let us create simulated data for a <strong>2-class example</strong>. First, let us create symmetric positive definite matrices (real positive definite matrices):</p><pre><code class="language-none">using PosDefManifoldML

PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80)</code></pre><ul><li><code>PTr</code> is the simulated training set, holding 30 matrices for class 1 and 40 matrices for class 2</li><li><code>PTe</code> is the testing set, holding 60 matrices for class 1 and 80 matrices for class 2.</li><li><code>yTr</code> is a vector of 70 labels for the training set</li><li><code>yTe</code> is a vector of 140 labels for the testing set</li></ul><p>All matrices are of size 10x10.</p><h2><a class="nav-anchor" id="Example-using-the-MDM-model-1" href="#Example-using-the-MDM-model-1">Example using the MDM model</a></h2><p>The <strong>minimum distance to mean (MDM)</strong> classifier is an example of classifier acting directly on the manifold. It is deterministic and no hyperparameter tuning is requested.</p><h3><a class="nav-anchor" id="MDM-Pipeline-1.-(fit-and-predict)-1" href="#MDM-Pipeline-1.-(fit-and-predict)-1">MDM Pipeline 1. (fit and predict)</a></h3><p><strong>Craete and fit an MDM model</strong></p><p>An MDM model is created and fit with training data such as</p><pre><code class="language-none">m = fit(MDM(Fisher), PTr, yTr)</code></pre><p>where <code>Fisher</code> is the usual choice of a <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a> as declared in the parent package <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/">PosDefManifold</a>.</p><p>The model can also be just created by</p><pre><code class="language-none">empty_model = MDM(Fisher)</code></pre><p>and fitted later using the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function.</p><p><strong>Predict (classify data)</strong></p><p>In order to predict the labels of unlabeled data, we invoke</p><pre><code class="language-none">yPred=predict(m, PTe, :l)</code></pre><p>The prediction error in percent can be retrived with</p><pre><code class="language-none">predictErr(yTe, yPred)</code></pre><p>If instead we wish to estimate the probabilities for the matrices in <code>PTe</code> of belonging to each class,</p><pre><code class="language-none">predict(m, PTe, :p)</code></pre><p>Finally, the output functions of the MDM are obtaine by (see <a href="../cv/#GLMNet.predict"><code>predict</code></a>)</p><pre><code class="language-none">predict(m, PTe, :f)</code></pre><h3><a class="nav-anchor" id="MDM-Pipeline-2.-(cross-validation)-1" href="#MDM-Pipeline-2.-(cross-validation)-1">MDM Pipeline 2. (cross-validation)</a></h3><p>The balanced accuracy estimated by a <em>k-fold cross-validation</em> is obtained such as</p><pre><code class="language-none">cv = cvAcc(MDM(Fisher), PTe, yTe, 5)</code></pre><p>where <code>5</code> is the number of folds. This implies that at each cross-validation, 1/5th of the matrices is used for training and the remaining for testing.</p><p>Struct <code>cv</code> has been created and therein you have access to average accuracy and confusion matrix as well as accuracies and confusion matrices for all folds. For example, print the average confusion matrix:</p><pre><code class="language-none">cv.avgCnf</code></pre><p>See <a href="../cv/#PosDefManifoldML.CVacc"><code>CVacc</code></a> for details on the fields of cross-validation objects.</p><h2><a class="nav-anchor" id="Example-using-the-ENLR-model-1" href="#Example-using-the-ENLR-model-1">Example using the ENLR model</a></h2><p>The <strong>elastic net logistic regression (ENLR)</strong> classifier is an example of classifier acting on the tangent space. It has two hyperparameters. The <strong>alpha</strong> hyperparameter is supplied by the user and allows to trade off between a pure <strong>ridge</strong> LR model (<span>$α=0$</span>) and a pure <strong>lasso</strong> LR model (<span>$α=1$</span>). Given an alpha value, the model is fitted with a number of values for the <strong>lambda</strong> hyperparameter. Thus, differently from the previous example, an additional step for tuning this hyperparameter is necessary. Also, keep in mind that the <a href="../cv/#StatsBase.fit"><code>fit</code></a> and <a href="../cv/#GLMNet.predict"><code>predict</code></a> methods for ENLR models accept optional keyword arguments that are specific to this model.</p><p><strong>get data</strong></p><p>Let us get some simulated data as in the previous example.</p><pre><code class="language-none">PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80)</code></pre><h3><a class="nav-anchor" id="ENLR-Pipeline-1.-(fit-and-predict)-1" href="#ENLR-Pipeline-1.-(fit-and-predict)-1">ENLR Pipeline 1. (fit and predict)</a></h3><p><strong>Craete and fit ENLR models</strong></p><p>By default, a lasso model is fitted:</p><pre><code class="language-none">m1 = fit(ENLR(Fisher), PTr, yTr)</code></pre><p>In order to fit a ridge LR model:</p><pre><code class="language-none">m2 = fit(ENLR(Fisher), PTr, yTr; alpha=0)</code></pre><p>Values of <code>alpha</code> in range <span>$(0, 1)$</span> fit an elastic net LR model. In the following we also request to standardize predictors:</p><pre><code class="language-none">m3 = fit(ENLR(Fisher), PTr, yTr; alpha=0.9, standardize=true)</code></pre><p>See the documentation of the <a href="../cv/#StatsBase.fit"><code>fit</code></a> ENLR method for details on all available optional arguments.</p><h4><a class="nav-anchor" id="Select-the-best-model-for-ENLR-1" href="#Select-the-best-model-for-ENLR-1">Select the best model for ENLR</a></h4><pre><code class="language-none">cvLambda!(m1, PTr, yTr)</code></pre><p>Note that the <a href="../cv/#StatsBase.fit"><code>fit</code></a> and <a href="../enlr/#PosDefManifoldML.cvLambda!"><code>cvLambda!</code></a> function have populated the <code>m1</code> struct. For example, try the following:</p><pre><code class="language-none">m1.path
m1.path.lambda
m1.bestModel
m1.bestλ
m1.cvλ.meanloss
m1.cvλ.stdloss
m1.cvλ.lambda</code></pre><p><strong>Classify data (predict)</strong></p><p>Since we have invoked the <code>cvLambda!</code> function to find the best model by cross-validation, by default this model is used for prediction:</p><pre><code class="language-none">yPred=predict(m1, PTe, :l)

# prediction error in percent
predictErr(yPred, yTe)

# predict probabilities of matrices in `PTe` to belong to each class
predict(m1, PTe, :p)

# output function of the model for each class
predict(m1, PTe, :f)</code></pre><p>The following two lines are equivalent</p><pre><code class="language-none">yPred=predict(m1, PTe, :l)
yPred=predict(m1, PTe, :l, m1.bestModel)</code></pre><p>We can also request the predition for all models, as</p><pre><code class="language-none">yPred=predict(m1, PTe, :l, 0)</code></pre><p>or of a specific model in the path, as</p><pre><code class="language-none">yPred=predict(m1, PTe, :l, 10)</code></pre><h3><a class="nav-anchor" id="ENLR-Pipeline-2.-(cross-validation)-1" href="#ENLR-Pipeline-2.-(cross-validation)-1">ENLR Pipeline 2. (cross-validation)</a></h3><p>The balanced accuracy estimated by a <em>k-fold cross-validation</em> is obtained with the exact same syntax for all models, thus, for example:</p><pre><code class="language-none">cv = cvAcc(ENLR(Fisher), PTe, yTe, 5)</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">PosDefManifoldML Documentation</span></a><a class="next" href="../MainModule/"><span class="direction">Next</span><span class="title">Main Module</span></a></footer></article></body></html>
