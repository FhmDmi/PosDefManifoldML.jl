<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tools ¬∑ PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li class="current"><a class="toctext" href>Tools</a><ul class="internal"><li><a class="toctext" href="#Content-1">Content</a></li></ul></li><li><span class="toctext">ML Models: PD Manifold</span><ul><li><a class="toctext" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="toctext">ML Models: PD Tangent Space</span><ul><li><a class="toctext" href="../enlr/">Elastic-Net Logistic Regression</a></li></ul></li><li><a class="toctext" href="../cv/">fit, predict, cv</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tools</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/tools.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tools</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="tools.jl-1" href="#tools.jl-1">tools.jl</a></h1><p>This unit implements tools that are useful for building Riemannian and Euclidean machine learning classifiers.</p><h2><a class="nav-anchor" id="Content-1" href="#Content-1">Content</a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.tsMap"><code>tsMap</code></a></td><td style="text-align: left">project data on a tangent space to apply Euclidean ML models therein</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.gen2ClassData"><code>gen2ClassData</code></a></td><td style="text-align: left">generate 2-class positive definite matrix data for testing Riemannian ML models</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.predictErr"><code>predictErr</code></a></td><td style="text-align: left">prediction error given a vector of true labels and a vector of predicted labels</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.tsMap" href="#PosDefManifoldML.tsMap"><code>PosDefManifoldML.tsMap</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function tsMap(	metric :: Metric,
		ùêè :: ‚ÑçVector;
		w :: Vector = [],
		‚úìw :: Bool = true,
		‚è© :: Bool = true,
		meanISR :: Union{‚Ñç, Nothing} = nothing,
		transpose :: Bool = true)</code></pre><p>The <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.logMap">tangent space mapping</a> of matrices <span>$P_i$</span>, <span>$i=1...k$</span> with geometric mean <span>$G$</span>, once those points have been parallel transported to the identity matrix, is given by:</p><p><span>$S_i=\textrm{log}(G^{-1/2} P_i G^{-1/2})$</span>.</p><p>Given a vector of <span>$k$</span> Hermitian matrices <code>ùêè</code>, return a matrix <span>$X$</span> with such tangent vectors of the matrices in <code>ùêè</code> vectorized as per the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> operation.</p><p>The mean <span>$G$</span> of the matrices in <code>ùêè</code> is found according to the specified <code>metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>. A natural choice is the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/introToRiemannianGeometry/#Fisher-1">Fisher metric</a>.</p><p>A set of <span>$k$</span> optional non-negative weights <code>w</code> can be provided for computing instead the weighted mean <span>$G$</span>. If <code>w</code> is non-empty and optional keyword argument <code>‚úìw</code> is true (default), the weights are normalized so as to sum up to 1, otherwise they are used as they are passed and should be already normalized. This option is provided to allow calling this function repeatedly without normalizing the same weights vector each time.</p><p>If an Hermitian matrix is provided as optional keyword argument <code>meanISR</code>, then the mean <span>$G$</span> is not computed, intead this matrix is used directly in the formula as the inverse square root (ISR) <span>$G^{-1/2}$</span>.</p><p>If <code>meanISR</code> is not provided, return the 2-tuple <span>$(X, G^{-1/2})$</span>, otherwise return only matrix <span>$X$</span>.</p><p>If optional keyword argument <code>transpose</code> is true (default), <span>$X$</span> holds the <span>$k$</span> vectorized tangent vectors in its rows, otherwise they are arranged in its columns. The dimension of the rows in the former case and of the columns is the latter case is <span>$n(n+1)/2$</span>, where <span>$n$</span> is the size of the matrices in <code>ùêè</code> (see <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> ).</p><p>if optional keyword argument <code>‚è©</code> if true (default), the computation of the mean (if this is obtained with an iterative algorithm, e.g., using the Fisher metric) and the projection on the tangent space are multi-threaded. Multi-threading is automatically disabled if the number of threads Julia is instructed to use is <span>$&lt;2$</span> or <span>$&lt;3k$</span>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using PosDefManifoldML

# generate four random symmetric positive definite 3x3 matrices
Pset = randP(3, 4)

# project and vectorize in the tangent space
X, G‚Åª¬Ω = tsMap(Fisher, Pset)

# X is a 4x6 matrix, where 6 is the size of the
# vectorized tangent vectors (n=3, n*(n+1)/2=6)

# If repeated calls have to be done, faster computations are obtained
# providing the inverse square root of the matrices in Pset, e.g.,
X1 = tsMap(Fisher, ‚ÑçVector(Pset[1:2]); meanISR =G‚Åª¬Ω)
X2 = tsMap(Fisher, ‚ÑçVector(Pset[3:4]); meanISR =G‚Åª¬Ω)</code></pre><p><strong>See</strong>: <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">the ‚ÑçVector type</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/eb72212dec075a7f8b4f15450359e6522af81744/src/tools.jl#L14-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.gen2ClassData" href="#PosDefManifoldML.gen2ClassData"><code>PosDefManifoldML.gen2ClassData</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function gen2ClassData(n        ::  Int,
                       k1train  ::  Int,
                       k2train  ::  Int,
                       k1test   ::  Int,
                       k2test   ::  Int,
                       separation :: Real = 0.1)</code></pre><p>Generate a <em>training set</em> of <code>k1train</code>+<code>k2train</code> and a <em>test set</em> of <code>k1test</code>+<code>k2test</code> symmetric positive definite matrices. All matrices have size <span>$n$</span>x<span>$n$</span>.</p><p>The training and test sets can be used to train and test any <a href="../MainModule/#MLmodel-1">MLmodel</a>.</p><p><code>separation</code> is a coefficient determining how well the two classs are separable; the higher it is, the more separable the two classes are. It must be in [0, 1] and typically a value of 0.5 already determines complete separation.</p><p>Return a 4-tuple with</p><ul><li>an <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a> holding the <code>k1train</code>+<code>k2train</code> matrices in the training set,</li><li>an ‚ÑçVector holding the <code>k1test</code>+<code>k2test</code> matrices in the test set,</li><li>a vector holding the <code>k1train</code>+<code>k2train</code> labels (integers) corresponding to the matrices of the training set,</li><li>a vector holding the <code>k1test</code>+<code>k2test</code> labels corresponding to the matrices of the test set (<span>$1$</span> for class 1 and <span>$2$</span> for class 2).</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.25)

# PTr=training set: 30 matrices for class 1 and 40 matrices for class 2
# PTe=testing set: 60 matrices for class 1 and 80 matrices for class 2
# all matrices are 10x10
# yTr=a vector of 70 labels for the training set
# yTe=a vector of 140 labels for the testing set
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/eb72212dec075a7f8b4f15450359e6522af81744/src/tools.jl#L118-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.predictErr" href="#PosDefManifoldML.predictErr"><code>PosDefManifoldML.predictErr</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function predictErr(yTrue::IntVector, yPred::IntVector;
	          digits::Int=3))</code></pre><p>Return the percent prediction error given a vector of true labels and a vector of predicted labels.</p><p>The order of arguments does not matter.</p><p>The error is rounded to the number of optional keyword argument <code>digits</code>, 3 by default.</p><p><strong>See</strong> <a href="../cv/#GLMNet.predict"><code>predict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML
predictErr([1, 1, 2, 2], [1, 1, 1, 2])
# return: 25.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/eb72212dec075a7f8b4f15450359e6522af81744/src/tools.jl#L211-L234">source</a></section><footer><hr/><a class="previous" href="../MainModule/"><span class="direction">Previous</span><span class="title">Main Module</span></a><a class="next" href="../mdm/"><span class="direction">Next</span><span class="title">Minimum Distance to Mean</span></a></footer></article></body></html>
