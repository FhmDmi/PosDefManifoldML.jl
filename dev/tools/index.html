<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tools · PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li class="current"><a class="toctext" href>Tools</a><ul class="internal"><li><a class="toctext" href="#Content-1">Content</a></li></ul></li><li><span class="toctext">ML Models: PD Manifold</span><ul><li><a class="toctext" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="toctext">ML Models: PD Tangent Space</span><ul><li><a class="toctext" href="../enlr/">Elastic-Net Logistic Regression</a></li><li><a class="toctext" href="../svm/">Support-Vector Machine</a></li></ul></li><li><a class="toctext" href="../cv/">fit, predict, cv</a></li><li><a class="toctext" href="../contribute/">How to contribute</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tools</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/tools.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tools</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="tools.jl-1" href="#tools.jl-1">tools.jl</a></h1><p>This unit implements tools that are useful for building Riemannian and Euclidean machine learning classifiers.</p><h2><a class="nav-anchor" id="Content-1" href="#Content-1">Content</a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.tsMap"><code>tsMap</code></a></td><td style="text-align: left">project data on a tangent space to apply Euclidean ML models therein</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.tsWeights"><code>tsWeights</code></a></td><td style="text-align: left">generator of weights for tagent space mapping</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.gen2ClassData"><code>gen2ClassData</code></a></td><td style="text-align: left">generate 2-class positive definite matrix data for testing Riemannian ML models</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.predictErr"><code>predictErr</code></a></td><td style="text-align: left">prediction error given a vector of true labels and a vector of predicted labels</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.rescale!"><code>rescale!</code></a></td><td style="text-align: left">Rescale the rows of a real matrix to be in range [a, b]</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.tsMap" href="#PosDefManifoldML.tsMap"><code>PosDefManifoldML.tsMap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function tsMap(	metric :: Metric,
				𝐏      :: ℍVector;
		w    	  :: Vector	= [],
		✓w   	  :: Bool = true,
		⏩   	 :: Bool = true,
		meanISR   :: Union{ℍ, Nothing}  = nothing,
		meanInit  :: Union{ℍ, Nothing}  = nothing,
		tol       :: Real               = 0.,
		transpose :: Bool   			 = true,
		vecRange  :: UnitRange          = 1:size(𝐏[1], 1))</code></pre><p>The <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.logMap">tangent space mapping</a> of positive definite matrices <span>$P_i$</span>, <span>$i=1...k$</span> with mean <span>$G$</span>, once those points have been parallel transported to the identity matrix, is given by:</p><p><span>$S_i=\textrm{log}(G^{-1/2} P_i G^{-1/2})$</span>.</p><p>Given a vector of <span>$k$</span> matrices <code>𝐏</code> flagged by julia as <code>Hermitian</code>, return a matrix <span>$X$</span> with such tangent vectors of the matrices in <code>𝐏</code> vectorized as per the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> operation.</p><p>The mean <span>$G$</span> of the matrices in <code>𝐏</code> is found according to the specified <code>metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>. A natural choice is the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/introToRiemannianGeometry/#Fisher-1">Fisher metric</a>. If the metric is Fisher, logdet0 or Wasserstein the mean is found with an iterative algorithm with tolerance given by optional keyword argument <code>tol</code>. By default <code>tol</code> is set by the function <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#Statistics.mean">mean</a>. For those iterative algorithms a particular initialization can be provided as an Hermitian matrix by optional keyword argument <code>meanInit</code>.</p><p>A set of <span>$k$</span> optional non-negative weights <code>w</code> can be provided for computing a weighted mean <span>$G$</span>, for any metrics. If <code>w</code> is non-empty and optional keyword argument <code>✓w</code> is true (default), the weights are normalized so as to sum up to 1, otherwise they are used as they are passed and should be already normalized. This option is provided to allow calling this function repeatedly without normalizing the same weights vector each time.</p><p>If an Hermitian matrix is provided as optional keyword argument <code>meanISR</code>, then the mean <span>$G$</span> is not computed, intead this matrix is used directly in the formula as the inverse square root (ISR) <span>$G^{-1/2}$</span>. If <code>meanISR</code> is provided, arguments <code>tol</code> and <code>meanInit</code> have no effect whatsoever.</p><p>If <code>meanISR</code> is not provided, return the 2-tuple <span>$(X, G^{-1/2})$</span>, otherwise return only matrix <span>$X$</span>.</p><p>If an <code>UnitRange</code> is provided with the optional keyword argument <code>vecRange</code>, the vectorization concerns only the columns (or rows) of the matrices <code>𝐏</code> specified by the range.</p><p>If optional keyword argument <code>transpose</code> is true (default), <span>$X$</span> holds the <span>$k$</span> vectorized tangent vectors in its rows, otherwise they are arranged in its columns. The dimension of the rows in the former case and of the columns is the latter case is <span>$n(n+1)÷2$</span> (integer division), where <span>$n$</span> is the size of the matrices in <code>𝐏</code>, unless a <code>vecRange</code> spanning a subset of the columns or rows of the matrices in <code>𝐏</code> has been provided, in which case the dimension will be smaller. (see <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> ).</p><p>if optional keyword argument <code>⏩</code> if true (default), the computation of the mean and the projection on the tangent space are multi-threaded. Multi-threading is automatically disabled if the number of threads Julia is instructed to use is <span>$&lt;2$</span> or <span>$&lt;2k$</span>.</p><p><strong>Examples</strong>:</p><pre><code class="language-none">using PosDefManifoldML

# generate four random symmetric positive definite 3x3 matrices
Pset = randP(3, 4)

# project and vectorize in the tangent space
X, G⁻½ = tsMap(Fisher, Pset)

# X is a 4x6 matrix, where 6 is the size of the
# vectorized tangent vectors (n=3, n*(n+1)/2=6)

# If repeated calls have to be done, faster computations are obtained
# providing the inverse square root of the matrices in Pset, e.g.,
X1 = tsMap(Fisher, ℍVector(Pset[1:2]); meanISR = G⁻½)
X2 = tsMap(Fisher, ℍVector(Pset[3:4]); meanISR = G⁻½)</code></pre><p><strong>See</strong>: <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">the ℍVector type</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/746ed19ba7925130c98ebfde2d1a800669647410/src/tools.jl#L13-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.tsWeights" href="#PosDefManifoldML.tsWeights"><code>PosDefManifoldML.tsWeights</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function tsWeights(y::Vector{Int}; classWeights=[])</code></pre><p>Given an <a href="../MainModule/#IntVector-1">IntVector</a> of labels <code>y</code>, return a vector of weights summing up to 1 such that the overall weight is the same for all classes (balancing). This is useful for machine learning models in the tangent space with unbalanced classes for computing the mean, that is, the base point to map PD matrices onto the tangent space. For this mapping, giving equal weights to all observations actually overweights the larger classes and downweight the smaller classes.</p><p>Class labels for <span>$n$</span> classes must be the first <span>$n$</span> natural numbers, that is, <code>1</code> for class 1, <code>2</code> for class 2, etc. The labels in <code>y</code> can be provided in any order.</p><p>if a vector of <span>$n$</span> weights is specified as optional keyword argument <code>classWeights</code>, the overall weights for each class will be first balanced (see here above), then weighted by the <code>classWeights</code>. This allow user-defined control of weighting independently from the number of observations in each class. The weights in <code>classWeights</code> can be any integer or real non-negative numbers. The returned weight vector will nonetheless sum up to 1.</p><p>When you invoke the <a href="../cv/#StatsBase.fit"><code>fit</code></a> function for tangent space models you don&#39;t actually need this function, as you can invoke it implicitly passing symbol <code>:balanced</code> (or just <code>:b</code>) or a tuple with the class weights as optional keyword argument <code>w</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none"># generate some data; the classes are unbalanced
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.1)

# Fit an ENLR lasso model and find the best model by cross-validation
# balancing the weights for tangent space mapping
m=fit(ENLR(), PTr, yTr; w=tsWeights(yTr))

# A simpler syntax is
m=fit(ENLR(), PTr, yTr; w=:balanced)

# to balance the weights and then give overall weight 0.5 to class 1
# and 1.5 to class 2:
m=fit(ENLR(), PTr, yTr; w=(0.5, 1.5))

# which is equivalent to
m=fit(ENLR(), PTr, yTr; w=tsWeights(yTr; classWeights=(0.5, 1.5)))


# This is how it works:

julia&gt; y=[1, 1, 1, 1, 2, 2]
6-element Array{Int64,1}:
 1
 1
 1
 1
 2
 2

We want the four observations of class 1 to count as much
as the two observations of class 2.

julia&gt; tsWeights(y)
6-element Array{Float64,1}:
 0.125
 0.125
 0.125
 0.125
 0.25
 0.25

i.e., 0.125*4 = 1.25*2
and all weights sum up to 1

Now, suppose we want to give to class 2 a weight
four times bigger as compared to class 1:

julia&gt; tsWeights(y, classWeights=[1, 4])
6-element Array{Float64,1}:
 0.05
 0.05
 0.05
 0.05
 0.4
 0.4

and, again, all weights sum up to 1
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/746ed19ba7925130c98ebfde2d1a800669647410/src/tools.jl#L145-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.gen2ClassData" href="#PosDefManifoldML.gen2ClassData"><code>PosDefManifoldML.gen2ClassData</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function gen2ClassData(n        ::  Int,
                       k1train  ::  Int,
                       k2train  ::  Int,
                       k1test   ::  Int,
                       k2test   ::  Int,
                       separation :: Real = 0.1)</code></pre><p>Generate a <em>training set</em> of <code>k1train</code>+<code>k2train</code> and a <em>test set</em> of <code>k1test</code>+<code>k2test</code> symmetric positive definite matrices. All matrices have size <span>$n$</span>x<span>$n$</span>.</p><p>The training and test sets can be used to train and test any <a href="../MainModule/#MLmodel-1">MLmodel</a>.</p><p><code>separation</code> is a coefficient determining how well the two classs are separable; the higher it is, the more separable the two classes are. It must be in [0, 1] and typically a value of 0.5 already determines complete separation.</p><p>Return a 4-tuple with</p><ul><li>an <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">ℍVector</a> holding the <code>k1train</code>+<code>k2train</code> matrices in the training set,</li><li>an ℍVector holding the <code>k1test</code>+<code>k2test</code> matrices in the test set,</li><li>a vector holding the <code>k1train</code>+<code>k2train</code> labels (integers) corresponding to the matrices of the training set,</li><li>a vector holding the <code>k1test</code>+<code>k2test</code> labels corresponding to the matrices of the test set (<span>$1$</span> for class 1 and <span>$2$</span> for class 2).</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML

PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.25)

# PTr=training set: 30 matrices for class 1 and 40 matrices for class 2
# PTe=testing set: 60 matrices for class 1 and 80 matrices for class 2
# all matrices are 10x10
# yTr=a vector of 70 labels for the training set
# yTe=a vector of 140 labels for the testing set
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/746ed19ba7925130c98ebfde2d1a800669647410/src/tools.jl#L265-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.predictErr" href="#PosDefManifoldML.predictErr"><code>PosDefManifoldML.predictErr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function predictErr(yTrue::IntVector, yPred::IntVector;
	          		digits::Int=3))</code></pre><p>Return the percent prediction error given a vector of true labels and a vector of predicted labels.</p><p>The order of arguments does not matter.</p><p>The error is rounded to the number of optional keyword argument <code>digits</code>, 3 by default.</p><p><strong>See</strong> <a href="../cv/#StatsBase.predict"><code>predict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-none">using PosDefManifoldML
predictErr([1, 1, 2, 2], [1, 1, 1, 2])
# return: 25.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/746ed19ba7925130c98ebfde2d1a800669647410/src/tools.jl#L358-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.rescale!" href="#PosDefManifoldML.rescale!"><code>PosDefManifoldML.rescale!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function rescale!(	X::Matrix{T},
					bounds::Tuple=(-1, 1);
					dims::Int=1) where T&lt;:Real</code></pre><p>Rescale the columns or the rows of real matrix <code>X</code> to be in range [a, b], where a and b are the first and seconf elements of tuple <code>bounds</code>.</p><p>By default rescaling apply to the columns. Use <code>dims=2</code> for rescaling the rows.</p><p>This function is used, for instance, by the SVM fit and predict functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/746ed19ba7925130c98ebfde2d1a800669647410/src/tools.jl#L396-L409">source</a></section><footer><hr/><a class="previous" href="../MainModule/"><span class="direction">Previous</span><span class="title">Main Module</span></a><a class="next" href="../mdm/"><span class="direction">Next</span><span class="title">Minimum Distance to Mean</span></a></footer></article></body></html>
