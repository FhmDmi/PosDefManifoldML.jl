<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tools · PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li><a class="toctext" href="../tutorial/">Tutorials</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../train_test/">Training-Testing</a></li><li class="current"><a class="toctext" href>Tools</a><ul class="internal"><li><a class="toctext" href="#Content-1">Content</a></li></ul></li><li><span class="toctext">Machine Learning Models</span><ul><li><a class="toctext" href="../mdm/">Minimum Distance to Mean</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tools</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/tools.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tools</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="tools.jl-1" href="#tools.jl-1">tools.jl</a></h1><p>This unit implements tools that are useful for building Riemannian and Euclidean machine learning classifiers.</p><h2><a class="nav-anchor" id="Content-1" href="#Content-1">Content</a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.projectOnTS"><code>projectOnTS</code></a></td><td style="text-align: left">project data on a tangent space to apply Euclidean ML models</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.CVsetup"><code>CVsetup</code></a></td><td style="text-align: left">generate indexes for performing cross-validtions</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.gen2ClassData"><code>gen2ClassData</code></a></td><td style="text-align: left">generate 2-class positive definite matrix data for testing Riemannian ML models</td></tr></table><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.projectOnTS" href="#PosDefManifoldML.projectOnTS"><code>PosDefManifoldML.projectOnTS</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function projectOnTS(metric :: Metric,
                     𝐏      :: ℍVector;
                  w  :: Vector = [],
                  ✓w :: Bool   = true,
                  ⏩ :: Bool   = true)</code></pre><p>Given a vector of <span>$k$</span> Hermitian matrices <code>𝐏</code> and corresponding optional non-negative weights <code>w</code>, return a matrix with the matrices <code>𝐏</code> mapped onto the tangent space at base-point given by their mean and vectorized as per the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> operation.</p><p><a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.logMap">Tangent space mapping</a> of matrices <span>$P_i, i=1...k$</span> at base point <span>$G$</span> according to the Fisher metric is given by:</p><p><span>$S_i=G^{½} \textrm{log}(G^{-½} P_i G^{-½}) G^{½}$</span>.</p><div class="admonition note"><div class="admonition-title">Nota Bene</div><div class="admonition-text"><p>the tangent space projection is currently supported only for the Fisher metric, therefore this metric is used for the projection.</p></div></div><p>The mean of the meatrices in <code>𝐏</code> is computed according to the specified <code>metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>. A natural choice is the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/introToRiemannianGeometry/#Fisher-1">Fisher metric</a>. The weighted mean is computed if weights vector <code>w</code> is non-empty. By default the unweighted mean is computed.</p><p>If <code>w</code> is non-empty and optional keyword argument <code>✓w</code> is true (default), the weights are normalized so as to sum up to 1, otherwise they are used as they are passed and should be already normalized. This option is provided to allow calling this function repeatedly without normalizing the same weights vector each time.</p><p>if optional keyword argument <code>⏩</code> if true (default), the computation of the mean is multi-threaded if this is obtained with an iterative algorithm (e.g., using the Fisher metric). Multi-threading is automatically disabled if the number of threads Julia is instructed to use is <span>$&lt;2$</span> or <span>$&lt;4k$</span>.</p><p>Return a matrix holding the <span>$k$</span> mapped matrices in its columns. The dimension of the columns is <span>$n(n+1)/2$</span>, where <span>$n$</span> is the size of the matrices in <code>𝐏</code> (see <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> ). The arrangement of tangent vectors in the columns of a matrix is natural in Julia, however if you export the tagent vectors to be used as feature vectors keep in mind that several ML packages, for example Python <em>scikitlearn</em>, expect them to be arranged in rows.</p><p><strong>Examples</strong>:</p><pre><code class="language-none"># generate four random symmetric positive definite 3x3 matrices
𝐏=randP(3, 4)

# project and vectorize in the tangent space
T=projectOnTS(Fisher, 𝐏)

# The result is a 6x4 matrix, where 6 is the size of the
# vectorized tangent vectors (n=3, n*(n+1)/2=6)</code></pre><p><strong>See</strong>: <a href="../MainModule/#the-ℍVector-type-1">the ℍVector type</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/8107bce45d91c59b16ccd0eb9292914991afe781/src/tools.jl#L14-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.CVsetup" href="#PosDefManifoldML.CVsetup"><code>PosDefManifoldML.CVsetup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function CVsetup(k       :: Int,
                 nCV     :: Int;
                 shuffle :: Bool = false)</code></pre><p>Given <code>k</code> elements and a parameter <code>nCV</code>, a nCV-fold cross-validation is obtained defining <span>$nCV$</span> permutations of <span>$k$</span> elements in <span>$nTest=k÷nCV$</span> (intger division) elements for the test and <span>$k-nTest$</span> elements for the training, in such a way that each element is represented in only one permutation.</p><p>Said differently, given a length <code>k</code> and the number of desired cross-validations <code>nCV</code>, this function generates indices from the sequence of natural numbers <span>$1,..,k$</span> to obtain all nCV-fold cross-validation sets. Specifically, it generates <span>$nCV$</span> vectors of indices for generating test sets and <span>$nCV$</span> vectors of indices for geerating training sets.</p><p>If optional keyword argument <code>shuffle</code> is true, the sequence of natural numbers <span>$1,..,k$</span> is shuffled before running the function, thus in this case two successive runs of this function will give different cross-validation sets, hence different accuracy scores. By default <code>shuffle</code> is false, so as to allow exactly the same result in successive runs. Notae that no random initialization for the shuffling is provided, so as to allow the replication of the same random sequences starting again the random generation from scratch.</p><p>This function is used in <a href="../mdm/#PosDefManifoldML.CV_mdm"><code>CV_mdm</code></a>. It constitutes the fundamental basis to implement customized cross-validation iprocedures.</p><p>Return the 4-tuple with:</p><ul><li>The size of each training set (integer),</li><li>The size of each testing set (integer),</li><li>A vector of <code>nCV</code> vectors holding the indices for the training sets,</li><li>A vector of <code>nCV</code> vectors holding the indices for the corresponding test sets.</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">CVsetup(10, 2)
# return:
# (5, 5,
# Array{Int64,1}[[6, 7, 8, 9, 10], [1, 2, 3, 4, 5]])
# Array{Int64,1}[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]],

CVsetup(10, 2, shuffle=true)
# return:
# (5, 5,
# Array{Int64,1}[[5, 4, 6, 1, 9], [3, 7, 8, 2, 10]])
# Array{Int64,1}[[3, 7, 8, 2, 10], [5, 4, 6, 1, 9]],



CVsetup(10, 3)
# return:
# (7, 3,
# Array{Int64,1}[[4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6]])
# Array{Int64,1}[[1, 2, 3], [4, 5, 6], [7, 8, 9, 10]],

</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/8107bce45d91c59b16ccd0eb9292914991afe781/src/tools.jl#L103-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifoldML.gen2ClassData" href="#PosDefManifoldML.gen2ClassData"><code>PosDefManifoldML.gen2ClassData</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">function gen2ClassData(n        ::  Int,
                       k1train  ::  Int,
                       k2train  ::  Int,
                       k1test   ::  Int,
                       k2test   ::  Int,
                       separation :: Real = 0.1)</code></pre><p>Generate a <em>training set</em> of <code>k1train</code>+<code>k2train</code> and a <em>test set</em> of <code>k1test</code>+<code>k2test</code> symmetric positive definite matrices. All matrices have size <span>$n$</span>x<span>$n$</span>.</p><p>The training and test sets can be used to train and test an <a href="../MainModule/#ML-model-1">ML model</a>.</p><p><code>separation</code> is a coefficient determining how well the two classs are separable; the higher it is, the more separable the two classes are. It must be in [0, 1] and typically a value of 0.5 already determines complete separation.</p><p>Return a 4-tuple with</p><ul><li>an <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">ℍVector</a> holding the <code>k1train</code>+<code>k2train</code> matrices in the training set,</li><li>an ℍVector holding the <code>k1test</code>+<code>k2test</code> matrices in the test set,</li><li>a vector holding the <code>k1train</code>+<code>k2train</code> labels (integers) corresponding to the matrices of the training set,</li><li>a vector holding the <code>k1test</code>+<code>k2test</code> labels corresponding to the matrices of the test set (<span>$1$</span> for class 1 and <span>$2$</span> for class 2).</li></ul><p><strong>Examples</strong></p><pre><code class="language-none">𝐏Tr, 𝐏Te, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.25)

# 𝐏Tr=training set: 30 matrices for class 1 and 40 matrices for class 2
# 𝐏Te=testing set: 60 matrices for class 1 and 80 matrices for class 2
# all matrices are 10x10
# yTr=a vector of 70 labels for 𝐓r
# yTe=a vector of 140 labels for 𝐓e
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/8107bce45d91c59b16ccd0eb9292914991afe781/src/tools.jl#L190-L231">source</a></section><footer><hr/><a class="previous" href="../train_test/"><span class="direction">Previous</span><span class="title">Training-Testing</span></a><a class="next" href="../mdm/"><span class="direction">Next</span><span class="title">Minimum Distance to Mean</span></a></footer></article></body></html>
