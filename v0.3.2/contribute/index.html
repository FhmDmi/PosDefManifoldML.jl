<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to contribute ¬∑ PosDefManifoldML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><h1>PosDefManifoldML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">PosDefManifoldML Documentation</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../MainModule/">Main Module</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><span class="toctext">ML Models: PD Manifold</span><ul><li><a class="toctext" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="toctext">ML Models: PD Tangent Space</span><ul><li><a class="toctext" href="../enlr/">Elastic-Net Logistic Regression</a></li><li><a class="toctext" href="../svm/">Support-Vector Machine</a></li></ul></li><li><a class="toctext" href="../cv/">fit, predict, cv</a></li><li class="current"><a class="toctext" href>How to contribute</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>How to contribute</a></li></ul><a class="edit-page" href="https://github.com/Marco-Congedo/PosDefManifoldML.jl/blob/master/docs/src/contribute.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>How to contribute</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="How-to-Contribute-1" href="#How-to-Contribute-1">How to Contribute</a></h1><p>You can easily contribute a new ML model to <em>PosDefManifoldML.jl</em> package following these steps:</p><p>Let&#39;s say you want to contribute an ML model named <code>ABC</code>.</p><p>If the model act on the manifold of positive definite matrices (PSD), use as template the <em>mdm.jl</em> unit. If it acts on the tangent space, use as template the <em>svm.jl</em> unit (you can also check the <em>enlr.jl</em> unit).</p><p>Save the template unit as unit <code>abc.jl</code> in the same directory where the template file is.</p><p>Implementing your <code>ABC</code> model entails the following five steps:</p><p><strong>1) Declare an abstract type for the model</strong></p><p>if your model acts on the manifold of PSD matrices, this will be</p><pre><code class="language-none">abstract type ABCmodel&lt;:PDmodel end</code></pre><p>if your model act on the tangent space, this will be</p><pre><code class="language-none">abstract type ABCmodel&lt;:TSmodel end</code></pre><p><strong>2) Declare the struct to hold the model and its default creator</strong></p><p>This will look like:</p><pre><code class="language-none">mutable struct ABC &lt;: ABCmodel
		metric        :: Metric
		defaultkwarg1 :: Type_of_defaultkwarg1
		defaultkwarg2 :: Type_of_defaultkwarg2
		...
		voidkwarg1
		voidkwarg2
		...
		function ABC(metric :: Metric=Fisher;
				defaultkwarg1 :: Type_of_defaultkwarg1 = default_value,
				defaultkwarg2 :: Type_of_defaultkwarg2 = default_value,
				...
				voidkwarg1 = nothing,
				voidkwarg2 = nothing,
				...)
			new(metric, defaultkwarg1, defaultkwarg1,...,
				voidkwarg1, voidkwarg2,...)
		end
end</code></pre><p>In the above example <code>defaultkwarg</code> are essential parameters that should be set by default upon creation. Use as few as those as needed to obtain a working ML model when the user does not pass any argument.</p><p>The <code>voidkwarg</code> arguments are arguments that you wish be accessible to the user in the structure once the model has been fitted. Include here as few of them as possible.</p><p><strong>3) write the <code>fit</code> function</strong></p><p>This function will fit the model. Its default behavior should fit the model and tune hyperparameters in order to find the best model by cross-validation if the <code>ABC</code> model has hyperparameters.</p><p>Your <code>fit</code> function declaration will look like:</p><pre><code class="language-none">function fit(   model :: ABCmodel,
			    ùêèTr :: ‚ÑçVector,
				# if the model acts on the tangent space use:
				# ùêèTr :: Union{‚ÑçVector, Matrix{Float64}}
				yTr :: Vector;
				verbose :: Bool = true
				kwarg1  :: type-of-kwarg1 = default-value,
				kwarg2  :: type-of-kwarg2 = default-value,
				...)
end</code></pre><p>Here you can use as many <code>kwarg</code> arguments as you wish. Currently, all ML models have a <code>verbose</code> argument. Your <code>fit</code> function should starts with:</p><pre><code class="language-none">‚åö=now() # time in milliseconds
‚Ñ≥=deepcopy(model) # output model</code></pre><p>and ends with</p><pre><code class="language-none">verbose &amp;&amp; println(defaultFont, &quot;Done in &quot;, now()-‚åö,&quot;.&quot;)
return ‚Ñ≥</code></pre><p>In between these two blocks you will fit the model and write into <code>‚Ñ≥</code> the <code>voidkwarg</code> arguments you have declared in the <code>ABC</code> struct (see above).</p><p>Keep in mind that if the model acts in the tangent space you will need to project the data therein. For doing so you can use the <code>_getFeat_fit!</code> internal function (declared in unit <em>tools.jl</em>), as it is done for the <em>ENLR</em> and <em>SVM</em> models. This entails using some standard arguments for tangent space projection, which should be given as options to the user, as done for these models. See how this is done in the <code>fit</code> function of the <em>ENLR</em> and <em>SVM</em> models (unit <code>enlr.jl</code> and <code>svm.jl</code>, respectively).</p><p>Once you have finished, a call such as</p><pre><code class="language-none">m1 = fit(ABC(), PTr, yTr)</code></pre><p>for some data <code>PTr</code>(a matrix or <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a> type) and labels <code>yTr</code> (see <a href="../cv/#StatsBase.fit"><code>fit</code></a>) should fit the model in such a way that it is ready to allow a call to the <code>predict</code> function and return the model.</p><p><strong>4) write the <code>predict</code> function</strong></p><p>Your <code>predict</code> function declaration will look like:</p><pre><code class="language-none">function predict(model   :: ABCmodel,
				ùêèTe :: Union{‚ÑçVector, Matrix{Float64}},
				# if the model acts on the tangent space use:
				# ùêèTr :: Union{‚ÑçVector, Matrix{Float64}}
				what :: Symbol = :labels;
				kwarg1 :: type_of_kwarg1 = default_value
				kwarg2 :: type_of_kwarg2 = default_value
				...
				verbose  :: Bool = true)</code></pre><p>where in general here you will not need <code>kwarg</code> arguments.</p><p>Your <code>predict</code> function should starts with:</p><pre><code class="language-none">‚åö=now() # time in milliseconds</code></pre><p>and ends with</p><pre><code class="language-none">verbose &amp;&amp; println(defaultFont, &quot;Done in &quot;, now()-‚åö,&quot;.&quot;)
verbose &amp;&amp; println(titleFont, &quot;\nPredicted &quot;,_what2Str(what),&quot;:&quot;, defaultFont)
return üÉè</code></pre><p>where in between these two blocks variable <code>üÉè</code> has been filled with the prediction.</p><p>To use this template code, in the declaration of the <code>_what2Str</code> function (declared in unit <em>tools.jl</em>), add a line to allow returning the full name of your model as a string.</p><p>As for the <code>fit</code> function, if the model acts in the tangent space you will need to project the data therein. For doing so you can use here the <code>_getFeat_Predict!</code> internal function (declared in unit <em>tools.jl</em>), as it is done for the <em>ENLR</em> and <em>SVM</em> models. This entails using some standard arguments for tangent space projection, which should be given as options to the user, as done for these models. Note that <code>_getFeat_Predict!</code> is similar, but not the same as <code>_getFeat_fit!</code> function.</p><p>All ML models implemented so far allow three types of prediction, depending on the symbol passed by the user with argument <code>what</code>. See the documentation of the <a href="../cv/#StatsBase.predict"><code>predict</code></a> function for the <em>ENLR</em> model to see what these three types of predictions are and the code of the function in unit <em>enlr.jl</em> for an example on how to compute them. Note that the returned type of the <code>predict</code> function, the variable <code>üÉè</code>, depends on <code>what</code> is predicted.</p><p><strong>5) Allow the <code>cvAcc</code> function to support your model properly</strong></p><p>If you have been following these guidelines so far, the <a href="../cv/#PosDefManifoldML.cvAcc"><code>cvAcc</code></a> function (declared in unit <em>cv.jl</em>) will be able to perform k-fold cross-validation on data using your <code>ABC</code> model.</p><p>This function allows the user to pass an arbitrary number of optional keyword arguments, so the user will be able to pass here the <code>kwarg</code> arguments you have declared in your <code>fit</code> function for the <code>ABC</code> model and those will be passed to the <code>fit</code> function when fitting the model at each fold.</p><p>This will be done automatically, however it is necessary to prevent the user from passing here optional keyword arguments that should not be used in a k-fold cross-validation setting (if in your <code>fit</code> function you have declared such arguments).</p><p>Also, it is necessary here to overwrite into the <code>ABC</code> model that is passed by the user as argument to the <a href="../cv/#PosDefManifoldML.cvAcc"><code>cvAcc</code></a> function the <code>defaultkwarg1</code> fields of the <code>ABC</code> struct you have declared, if the user can request different values for those fields using optional keyword arguments passed to the <a href="../cv/#PosDefManifoldML.cvAcc"><code>cvAcc</code></a> function. For example, consider the <em>SVM</em> model; suppose the user pass to the <a href="../cv/#PosDefManifoldML.cvAcc"><code>cvAcc</code></a> function a default SVM model. For such a model the kernel is a radial basis kernel. Suppose the user has passed to the <a href="../cv/#PosDefManifoldML.cvAcc"><code>cvAcc</code></a> function argument <code>kernel=linear</code>. If you don&#39;t overwrite the kernel into the model, the radianl basis kernel will be used instead of the desired linear kernel.</p><p>You can do so easily using the <code>_rmArgs</code> and <code>_getArgValue</code> internal functions (declared in unit <em>tools.jl</em>), as done for the <em>SVM</em> and <em>ENLR</em> model (see the code of the <a href="../cv/#PosDefManifoldML.cvAcc"><code>cvAcc</code></a> function).</p><footer><hr/><a class="previous" href="../cv/"><span class="direction">Previous</span><span class="title">fit, predict, cv</span></a></footer></article></body></html>
